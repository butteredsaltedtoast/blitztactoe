<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlitzTacToe - Game</title>
    <style>
        .hidden { display: none !important; }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .container { text-align: center; padding: 20px; }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        #game-over-actions {
          animation: fadeIn 0.5s ease;
        }

        @keyframes slideOffLeft {
          0% {
            transform: translateX(0) rotate(0deg);
            opacity: 1;
          }
          100% {
            transform: translateX(-120vw) rotate(-20deg);
            opacity: 0;
          }
        }

        @keyframes slideInRight {
          0% {
            transform: translateX(120vw) rotate(20deg);
            opacity: 0;
          }
          100% {
            transform: translateX(0) rotate(0deg);
            opacity: 1;
          }
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 4px;
            margin: 20px auto;
        }

        .board.active {
          animation: fadeIn 0.3s ease;
        }

        .board.slide-off {
          animation: slideOffLeft 0.4s ease forwards;
        }

        .board.slide-in {
          animation: slideInRight 0.4s ease;
        }

        @keyframes pop {
          0% { transform: scale(0.8); opacity: 0; }
          50% { transform: scale(1.1); }
          100% { transform: scale(1); opacity: 1; }
        }
        
        .cell {
            border: 1px solid #333;
            font-size: 2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
            transition: all 0.2s;
        }
        
        .cell[data-symbol="x"],
        .cell[data-symbol="o"] {
            animation: pop 0.2s ease;
        }

        .cell:hover {
            background: #222;
            border-color: #555;
            transform: scale(1.05);
        }

        .cell:active {
            transform: scale(0.95);
        }
        
        .info { display: flex; justify-content: center; gap: 20px; margin: 10px 0; }

        @keyframes urgentPulse {
          0%, 100% { opacity: 1;}
          50% { opacity: 0.5; }
        }

        #timer[data-remaining="3"] {
            color: #ffaa00;
        }

        #timer[data-remaining="2"], #timer[data-remaining="1"] {
            color: #ff4444;
            animation: urgentPulse 0.5s infinite;
        }

        @keyframes winglow {
          from { box-shadow: 0 0 10px rgba(0, 255, 100, 0.3); }
          to { box-shadow: 0 0 25px rgba(0, 255, 100, 0.1); }
        }

        @keyframes loseglow {
          from { box-shadow: 0 0 10px rgba(255, 68, 68, 0.3); }
          to { box-shadow: 0 0 25px rgba(255, 68, 68, 0.6); }
        }

        .cell[data-winning="true"][data-result="win"] {
          background: rgba(0, 255, 100, 0.1);
          border-color: #00ff64;
          animation: winglow 1s ease infinite alternate;
        }

        .cell[data-winning="true"][data-result="lose"] {
          background: rgba(255, 68, 68, 0.1);
          border-color: #ff4444;
          animation: loseglow 1s ease infinite alternate;
        }

        #status.win {
            color: #00ff64;
        }

        #status.lose {
            color: #ff4444;
        }

        #status.draw {
            color: #888;
        }

        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          20% { transform: translateX(-10px); }
          40% { transform: translateX(10px); }
          60% { transform: translateX(-10px); }
          80% { transform: translateX(10px); }
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
          }

          to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
          }
        }

        #toast {
          position: fixed;
          bottom: 30px;
          left: 50%;
          transform: translateX(-50%);
          background: #222;
          border: 1px solid #444;
          padding: 12px 24px;
          animation: slideUp 0.3s ease;
        }

        #game-over-actions {
          display: flex;
          gap: 15px;
          justify-content: center;
          margin-top: 30px;
          flex-wrap: wrap;
        }

        #rematch-btn {
          padding: 12px 32px;
          font-size: 1.1rem;
          font-weight: 600;
          border: 2px solid #ffaa00;
          background: linear-gradient(135deg, rgba(255, 166, 0, 0.1), rgba(255, 174, 0, 0.05));
          color: #ffffff;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(236, 155, 4, 0.2);
          position: relative;
          overflow: hidden;
        }

        #rematch-btn:hover:not(:disabled) {
          background: linear-gradient(135deg, rgba(255, 187, 0, 0.2), rgba(0, 255, 100, 0.1));
          box-shadow: 0 0 25px rgba(255, 196, 0, 0.4);
          transform: translateY(-2px);
        }

        #rematch-btn:active:not(:disabled) {
          transform: translateY(0);
          box-shadow: 0 0 15px rgba(255, 145, 0, 0.2);
        }

        #rematch-btn:disabled {
          border-color: #666;
          color: #666;
          background: linear-gradient(135deg, rgba(100, 100, 100, 0.1), rgba(100, 100, 100, 0.05));
          box-shadow: 0 0 10px rgba(100, 100, 100, 0.1);
          cursor: not-allowed;
          opacity: 0.7;
        }

        @keyframes buttonPulse {
          0%, 100% { box-shadow: 0 0 15px rgba(255, 166, 0, 0.2); }
          50% { box-shadow: 0 0 30px rgba(255, 187, 0, 0.5); }
        }

        #rematch-btn:not(:disabled) {
          animation: buttonPulse 2s ease infinite;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            animation: confetti-fall 3s linear forwards;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>BlitzTacToe</h1>
        <div id="status">Connecting...</div>
        <div id="timer">--</div>
        <div class="info">
            <div>
                <div>You are</div>
                <div id="your-symbol">-</div>
            </div>
            <div>
                <div>Current turn</div>
                <div id="current-turn">-</div>
            </div>
        </div>
        <div class="board" id="board"></div>
        <div id="game-over-actions" class="hidden">
            <button id="rematch-btn">Rematch</button>
        </div>
        <div id="toast" class="hidden"></div>
    </div>

    <script>
        let socket = null;
        let mySymbol = null;
        let currentTurn = null;
        let board = ["", "", "", "", "", "", "", "", ""];
        let gameOver = false;
        let gameStarted = false;
        let turnStarted = null;
        let turnTime = 5;
        let countdownInterval = null;

        const statusEl = document.getElementById("status");
        const timerEl = document.getElementById("timer");
        const yourSymbolEl = document.getElementById("your-symbol");
        const currentTurnEl = document.getElementById("current-turn");
        const boardEl = document.getElementById("board");
        const gameOverActions = document.getElementById("game-over-actions");
        const rematchBtn = document.getElementById("rematch-btn");
        const toastEl = document.getElementById("toast");

        function init() {
            createBoard();
            connectWebSocket();
            rematchBtn.addEventListener("click", requestRematch);
        }

        function createBoard() {
            boardEl.innerHTML = "";
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.dataset.index = i;
                cell.addEventListener("click", () => handleCellClick(i));
                boardEl.appendChild(cell);
            }
        }

        function connectWebSocket() {
            const roomId = window.location.pathname.split("/").filter(Boolean).pop();
            const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
            const wsUrl = `${protocol}//${window.location.host}/ws/game/${roomId}/`;

            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                setStatus("Connected. Waiting for opponent...");
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            };

            socket.onclose = () => {
                setStatus("Disconnected. Refresh to reconnect.");
                stopCountdown();
            };

            socket.onerror = () => {
                setStatus("Connection error.");
            };
        }

        function handleServerMessage(data) {
            switch (data.type) {
                case "init": handleInit(data); break;
                case "game_start": handleGameStart(data); break;
                case "turn_change": handleTurnChange(data); break;
                case "turn_timeout": handleTurnTimeout(data); break;
                case "game_over": handleGameOver(data); break;
                case "game_reset": handleGameReset(data); break;
                case "rematch_requested": handleRematchRequested(data); break;
                case "player_left": handlePlayerLeft(data); break;
            }
        }

        function handleInit(data) {
            mySymbol = data.symbol;
            board = data.board;
            currentTurn = data.turn;
            turnTime = data.turn_time;
            gameStarted = data.game_started;
            yourSymbolEl.textContent = mySymbol;
            renderBoard();

            if (gameStarted && data.turn_started) {
                startCountdown(data.turn_started, turnTime);
                updateTurnDisplay();
            } else {
                setStatus("Waiting for opponent...");
            }
        }

        function handleGameStart(data) {
            gameStarted = true;
            gameOver = false;
            currentTurn = data.turn;
            turnTime = data.turn_time;
            updateTurnDisplay();
            startCountdown(data.turn_started, turnTime);
            boardEl.classList.add('active');
            showToast("Game started!");
        }

        function handleTurnChange(data) {
            board = data.board;
            currentTurn = data.turn;
            renderBoard();
            updateTurnDisplay();
            startCountdown(data.turn_started, data.turn_time);
        }

        function handleTurnTimeout(data) {
            board = data.board;
            currentTurn = data.turn;
            renderBoard();
            updateTurnDisplay();
            startCountdown(data.turn_started, data.turn_time);
            showToast("Turn skipped (timeout)!");
        }

        function launchConfetti()
        {
            const colors = ['#ff4444', '#ffaa00', '#00ff64', '#00aaff', '#f5a927'];
            for(let i = 0; i < 50; i++)
            {

                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';

                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                    document.body.appendChild(confetti);

                    setTimeout(() => {
                        confetti.remove();
                    }, 4000);
                }, i * 100);

            }
        }

        function handleGameOver(data) {
            gameOver = true;
            board = data.board;
            stopCountdown();
            renderBoard();

            if (data.winner === "draw") {

                setStatus("it's a draw! again!!!");
                statusEl.className = "draw";

                boardEl.classList.add('slide-off');
                setTimeout(() => {

                  socket.send(JSON.stringify({action: "rematch"}));
                }, 500);

                return;

              } else if (data.winner === mySymbol) {

                setStatus("you win!!!!");
                statusEl.className = "win";
                launchConfetti();

              } else {

                setStatus("you lose....");
                statusEl.className = "lose";
                document.querySelector('.container').classList.add('shake');

              }

            highlightWinner(data.winner);

            if(data.winner !== "draw")
            {
              const cells = boardEl.querySelectorAll(".cell");
              cells.forEach(cell => {
                  if (cell.dataset.winning === "true") {
                    cell.dataset.result = (data.winner == mySymbol) ? "win" : "lose";
                  }
                
              });
            }

            gameOverActions.classList.remove("hidden");
            rematchBtn.disabled = false;
            rematchBtn.textContent = "Rematch";
            timerEl.textContent = "--";
        }

        function handleGameReset(data) {

          if(boardEl.classList.contains('slide-off')) {
            boardEl.classList.remove('slide-off');
            boardEl.classList.add('slide-in');
            setTimeout(() => {
              boardEl.classList.remove('slide-in');
            }, 400);
          }

            document.querySelector('.container').classList.remove('shake');
            statusEl.className = "";
            board = data.board;
            currentTurn = data.turn;
            gameOver = false;

            const cells = boardEl.querySelectorAll(".cell");
            cells.forEach(cell => {
              cell.dataset.winning = "";
              cell.dataset.result = "";
            });

            renderBoard();
            updateTurnDisplay();
            startCountdown(data.turn_started, data.turn_time);
            gameOverActions.classList.add("hidden");
            showToast("New game started!");
        }

        function handleRematchRequested(data) {
            if (data.symbol !== mySymbol) {
                showToast(`${data.symbol} wants a rematch!`);
            }
        }

        function handlePlayerLeft(data) {
            gameStarted = false;
            stopCountdown();
            setStatus(`Player ${data.symbol} left. Waiting for new opponent...`);
            timerEl.textContent = "--";
        }

        function handleCellClick(index) {
            if (!gameStarted) return;
            if (gameOver) return;
            if (currentTurn !== mySymbol) return;
            if (board[index] !== "") return;
            socket.send(JSON.stringify({ index: index }));
        }

        function requestRematch() {
            socket.send(JSON.stringify({ action: "rematch" }));
            rematchBtn.disabled = true;
            rematchBtn.textContent = "Waiting...";
            showToast("Rematch requested!");
        }

        function startCountdown(serverTurnStarted, serverTurnTime) {
            stopCountdown();

            if (!serverTurnStarted || !serverTurnTime) {
                timerEl.textContent = "--";
                return;
            }

            const startedAt = Date.now();

            turnTime = serverTurnTime;

            function updateTimer() {
                const elapsed = (Date.now() - startedAt) / 1000;
                const remaining = Math.max(0, Math.ceil(turnTime - elapsed));
                timerEl.textContent = remaining;
                timerEl.dataset.remaining = remaining;

                if (remaining <= 0) {
                    stopCountdown();
                }
            }

            updateTimer();
            countdownInterval = setInterval(updateTimer, 100);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function renderBoard() {
            const cells = boardEl.querySelectorAll(".cell");
            cells.forEach((cell, i) => {
                cell.textContent = board[i];
                cell.dataset.symbol = board[i].toLowerCase();
            });
        }

        function updateTurnDisplay() {
            currentTurnEl.textContent = currentTurn;
            if (currentTurn === mySymbol) {
                setStatus("Your turn!");
            } else {
                setStatus("Opponent's turn...");
            }
        }

        function setStatus(message) {
            statusEl.textContent = message;
        }

        function highlightWinner(winner) {
            if (winner === "draw") return;

            const wins = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];

            const cells = boardEl.querySelectorAll(".cell");
            for (const [a, b, c] of wins) {
                if (board[a] && board[a] === board[b] && board[b] === board[c]) {
                    cells[a].dataset.winning = "true";
                    cells[b].dataset.winning = "true";
                    cells[c].dataset.winning = "true";
                    break;
                }
            }
        }

        function showToast(message) {
            toastEl.textContent = message;
            toastEl.classList.remove("hidden");
            setTimeout(() => toastEl.classList.add("hidden"), 2500);
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html> 